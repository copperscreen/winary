using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using ICSharpCode.SharpZipLib.BZip2;

namespace winary
{
	using Dct = Dictionary<string,object>;
	using Lst = List<string>;
	class Program
	{
		enum State { Default, English, Pronunciation };
		static Regex latin = new Regex("[0-9a-zA-Z]");
		static Dct broken = new Dct();
		static Dct garbage = new Dct();
		static bool FindPattern(string text, Dct dict, string title, int offset) {
			int pos = 0;
			while (pos < text.Length) {
				int open = text.IndexOf("{{", pos);
				if (open != -1) {
					int close = text.IndexOf("}}", open);
					if (close != -1) {
						pos = close;
					} else { return true; }
				} else break;
			}
			return false;
		}
		static IEnumerable<string> Walk(Dct dict, string path) {
			foreach (var kv in dict) {
				yield return path + "@@" + kv.Key;
			}
			foreach (var kv in dict) {
				foreach (var tmp in Walk(kv.Value as Dct, path + "@@" + kv.Key)) yield return tmp;
			}
		}

	static void Main(string[] args)
        {
			var partsInside = new Dictionary<string, object>(); 
			var partsInside2 = new Dictionary<string, object>(); 
			var partsOutside = new Dictionary<string, object>();
			var titles = new HashSet<string>();
			var buf = new List<string>();
			var pronReg = new Regex("{{a[^}]*|US[^}]*}}.*{{IPA|en|([^}]*)}}");
			var reg = new Regex("{{[^}]*}}");
			var match = new HashSet<string>();
			var megaMatch = new Regex("{{(a|accent)([|]([^|}])+)*([|](GA|GenAm|GAm|US|General American))+([|]([^|}])+)*}}.*{{IPA([|](en|lang=en|(?<pron>[[/][^}|]+[]/]))*)*}}", RegexOptions.Multiline);
			var english = new Regex("^=+English=");
			var pronunciation = new Regex("^=+Pronunciation=");
			var backupPron = new Regex("{{IPA([|](en|lang=en|(?<pron>[[/][^}|]+[]/]))*)*}}");
			var pron = new List<string>();
			var american = new HashSet<string>();
			var nonamerican = new HashSet<string>();
			//{{(a|accent)([|]([^|}])+)*([|](GA|GenAm|GAm|US|General American))+([|]([^|}])+)*}}.*{{IPA([|](en|[^|=}]+=[^|=}]+|(?<pron>[[/][^}|]+)))*}}

			//* {{accent|GA}} {{IPA|en|/kwɑˈdreɪ.təs/}}
			//* {{a|Canada|GA}} {{IPA|en|/dʒul/|/ˈdʒu.əl/}}
			//* {{a|Canada|GenAm|RP}} {{IPA|en|/ˈspɛlɪŋ/}}
			//* {{a|Canada|GenAm}} {{IPA|en|/sɔɹˈbeɪ/}}
			//* {{a|Canada|US|UK}} {{IPA|en|/ɹɪŋk/}}
			//* {{a|Canada|US}} {{IPA|en|/məˈski.toʊ/}}
			//* {{a|GAm}} {{IPA|en|/mɪlˈjʊ/|/mɪlˈjʊz/|/mɪlˈju/|/mɪlˈjuz/}}
			//* {{a|GAm}} {{IPA|en|/mɪlˈjʊ/|/mɪlˈjʊz/|/mɪlˈju/|/mɪlˈjuz/}}
			//* {{a|GA|CA|[[w:/æ/ raising|/æ/ raising]]}} {{IPA|en|[kʰɛənədə]}} ~ {{IPAchar|[kʰeənədə]}}
			//* {{a|GA|CA}} {{IPA|en|/kɛɹnz/}}
			//* {{a|GA|Canada|cot-caught}} {{IPA|en|/ˈkʌmˌɑn/}}
			//* {{a|GA|Canada}} {{IPA|en|/dɑkˈsɑlədʒi/}}
			//* {{a|GA|Ireland}} {{IPA|en|/ɡɑd/}}
			//* {{a|GA|Mary-marry-merry}} {{IPA|en|/juˌtɪləˈtɛɹi.ən/}}
			//* {{a|GA|Mmmm}} {{IPA|en|/vaɪˈkɛɹi.əs/|/vəˈkɛɹi.əs/}}
			//* {{a|GA|Northern England}} {{IPA|en|/ɹɪˈpæst/|/ɹə-/}}
			//* {{a|GA|RP|rapid}} {{IPA|en|/ˈhæstə/}}
			//* {{a|GA|RP}} {{IPA|en|/bɹæd/}}
			//* {{a|GA|Scotland}} {{IPA|en|[kɔld]}}
			//* {{a|GA|Southern and Midland US}} {{IPA|en|/ˌ(h)wɛrəˈpɔn/}}
			//* {{a|GA|US}} {{IPA|en|/bædʒ/}}
			//* {{a|GA|pre-/ŋ/ tensing}}, {{IPA|en|/iŋk/}}
			//* {{a|GA|weak vowel}} {{IPA|en|/ˈmɚlət/}}<!-- generated by [[Template:X2IPA]] -->
			//* {{a|GA|weak-vowel merger}} {{IPA|en|[ˈfoɹt͡ʃənətʰ]|[ˈfoɹt͡ʃnətʰ]}}
			//* {{a|GA}} {{IPA|enm|/ˈivəlˌduːɚ/}}
			//* {{a|GA}} {{IPA|en|/ˈɔɹɪɡən/|/ˈɔɹəɡɪn/|/ˈɔɹɪɡɑn/|qual3=proscribed}}
			//* {{a|GA}} {{enPR|bā'ə-nĕtʹ|bāʹə-nĭt|bāʹə-nĕt'}}, {{IPA|en|/ˌbeɪəˈnɛt/|/ˈbeɪənɪ̈t/|/ˈbeɪəˌnɛt/}}
			//* {{a|GA}}, {{a|IE}} {{enPR|kŏlʹəm}}, {{IPA|en|/ˈkɑləm/}}
			//* {{a|GA}}: {{IPA|en|/əˈlʊɹɪŋ/|/əˈlɝɪŋ/}}
			//* {{a|GA}}{{IPA|en|/əˈbæk.əˌvɪɹ/}}
			//* {{a|GenAm}} {{IPA|/loʊˈkjutɚ/|/ˈlɒkjʊtɚ/|lang=en}}
			//* {{a|General American}} {{IPA|en|/fɪɹs/}}
			//* {{a|RP|GA}} {{IPA|en|/stɹɛŋkθ/|[st̠͡ɹ̠ɛŋkθ]|[st̠͡ɹ̠ɛn̪θ]}}
			//* {{a|RP|US}} {{IPA|en|/ˈsɪ.lə.bəl/|[ˈsɪləbɫ]}}
			//* {{a|UK|US|nonstandard}} {{IPA|en|/ʌnˈnɛs.ə.ɹɪ/}}
			//* {{a|US}} {{IPA|en|/baɪˈswɛp.t͡ʃu.əl/}}
			//* {{a|US}} {{enPR|kə-läzh'|kō-läzh'}}; {{IPA|en|/kəˈlɑʒ/|/koʊˈlɑʒ/}}
///////////////////////////////////////////


			string fileName = System.IO.Directory.GetFiles("../../../", "enwiktionary-*-pages-articles.xml.bz2").LastOrDefault();
			if (string.IsNullOrEmpty(fileName))
			{
				Console.WriteLine("Please drop an enwiktionary file from https://dumps.wikimedia.org/enwiki/latest/ here");
			}
			else
			{
				using (var file = new FileInfo(fileName).OpenRead())
				using (var bzip = new BZip2InputStream(file))
				using (XmlReader reader = XmlReader.Create(bzip))
				{
					string title = "";
					int count = 0;
					bool found = false;
					while (reader.Read())
					{
						if (reader.NodeType == XmlNodeType.Element)
						{
							if (reader.Name == "title")
							{
								titles.Add(title = reader.ReadElementContentAsString());
								count++;
								if (count % 10000 == 0)
									Console.Write('.');
								if (count % 500000 == 0)
									Console.WriteLine(buf.Count);
							}
							else if (reader.Name == "text")
							{
								found = false;
								int bufPos = buf.Count;
								var st = State.Default;
								string text = reader.ReadElementContentAsString();
								foreach (var line in text.Split('\n'))
								{
									if (english.Match(line).Success) st = State.English;
									else if (st == State.English && pronunciation.Match(line).Success) st = State.Pronunciation;
									else if (st == State.Pronunciation && !line.StartsWith("="))
									{
										pron.Add(line);
										if (FindPattern(line, partsInside, title, 0)) broken[title] = text;
										FindPattern(line, partsInside2, title, 1);
										foreach (Match m in megaMatch.Matches(line))
											if (m.Groups["pron"].Success)
											{
												buf.RemoveRange(bufPos, buf.Count - bufPos);
												buf.Add(title + " @ " + m.Groups["pron"].Value + " @a");
												titles.Remove(title);
												broken.Remove(title);
												garbage.Remove(title);
												found = true;
												american.Add(title);
												nonamerican.Remove(title);
											}
										if (!found)
											foreach (Match m in backupPron.Matches(line))
												if (m.Groups["pron"].Success)
												{
													buf.Add(title + " @ " + m.Groups["pron"].Value);
													titles.Remove(title);
													broken.Remove(title);
													garbage.Remove(title);
													found = true;
													nonamerican.Add(title);
												}
									}
									else if (st == State.Pronunciation && line.StartsWith("=")) break;
									else if (FindPattern(line, partsOutside, title, 1))
                                    {
										if (text.Contains("==English==")) broken[title] = text;
										else garbage[title] = text;
									}
								}
							}
						}
					}
				}
			}
			var sortedTitles = titles.ToList();
			sortedTitles.Sort();
			var sortedBroken = broken.Keys.ToList();
			sortedBroken.Sort();
			var sortedGarbage = garbage.Keys.ToList();
			sortedGarbage.Sort();
			var sortedAmerican = american.ToList();
			sortedAmerican.Sort();
			var sortedNonamerican = nonamerican.ToList();
			sortedNonamerican.Sort();
			File.WriteAllLines("../../../data0.txt", buf);
			File.WriteAllLines("../../../not_found.txt", sortedTitles);
			File.WriteAllLines("../../../no_transcr.txt", broken.Select(_ => "@@@@@@@@@@@@@@" + _.Key + "@@\r\n" + _.ToString()));
			File.WriteAllLines("../../../nonenglish.txt", garbage.Select(_ => "@@@@@@@@@@@@@@" + _.Key + "@@\r\n" + _.ToString()));
			File.WriteAllLines("../../../no_transcr_word.txt", sortedBroken);
			File.WriteAllLines("../../../nonenglish_word.txt", sortedGarbage);
			File.WriteAllLines("../../../pron.txt", pron);
			File.WriteAllLines("../../../american.txt", sortedAmerican);
			File.WriteAllLines("../../../nonamerican.txt", sortedNonamerican);
		}
	}
}
